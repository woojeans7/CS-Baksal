# CPU의 작동원리
CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치
연산장치(ALU), 제어장치, 레지스터로 구성되어있다.

## ALU(산술논리연산장치)
> 산술 연산과 논리 연산을 수행 

<img width="600" height="314" alt="image" src="https://github.com/user-attachments/assets/ed2d83df-7746-4071-97bc-ad7dca2972fb" />

#### ALU가 받아들이는 정보
- 계산을 하기 위해서는 피연산자와 수행할 연산이 필요함. 
- 레지스터를 통해 **피연산자**를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 **제어신호**를 받아들인다.

####  ALU가 내보내는 정보
- **연산을 수행한 결과**를 내보낸다. 
- **플래그(flag)** : 연산 결과에 대한 부가 정보, 플래그 레지스터에 저장됨

레지스터로부터 피연산자를 받아와 연산을 수행하고, 연산 결과를 다시 레지스터에 저장함.

## 제어장치
> 제어신호를 내보내고, 명령어를 해석함.

<img width="1888" height="884" alt="image" src="https://github.com/user-attachments/assets/343c7bf6-fea6-4869-9d17-b5e112cb950d" />

#### 제어장치가 받아들이는 정보
- **클럭(clock)**
- 해석할 **명령어**
- **플래그**
- 제어 버스를 통해 전달된 **제어 신호**
#### 제어장치가 내보내는 정보
- CPU 내부에 전달하는 제어 신호 (To. 레지스터, ALU)
- CPU 외부에 전달하는 제어 신호 (To. 기억장치, 입출력장치)

명령어를 해석하고, 그 결과에 따라 CPU 내외부의 각 장치에 제어 신호를 보내 명령어 실행을 제어한다.

## 레지스터
> CPU가 바로 사용할 데이터나 주소를 임시로 저장하는 공간, 고속기억장치

프로그램 속 명령어와 데이터는 실행 전후로 레지스터에 저장됨.
CPU 내부에는 다양한 레지스터들이 있고, 각자 다른 역할을 수행함.
또한, CPU마다 이름, 크기, 종류가 다양함. 

용도에 따라 **범용 레지스터**와 **특수 목적 레지스터**로 구분함.
### 특수 목적 레지스터
특별한 용도로 사용하는 레지스터
##### 1. 프로그램 카운터(PC| Program Counter)
- 메모리에서 읽어 들일 **명령어의 주소**를 저장함. 
- **명령어 포인터(IP)** 라고 부르는 CPU도 있음. 
##### 2. 명령어 레지스터(IR| Instruction Register)
- 해석할 명령어, 즉 메모리에서 방금 읽어 들인 **명령어**를 저장함. (현재 실행중인 명령어를 저장)
- 제어장치가 이를 해석하고 제어신호를 보냄
##### 3. 메모리 주소 레지스터(MAR| Memory Address Register)
- CPU가 읽거나 쓰려는 메모리의 주소를 저장함.
- 주소 버스로 주소를 전달할 때 사용
##### 4. 메모리 버퍼 레지스터(MBR| Memory Buffer Register)
- 메모리와 주고받을값(데이터와 명령어)을 저장
- 데이터 버스를 통해 메모리와 데이터를 주고받음
##### 5. 플래그 레지스터(Flag Register)
-  연산 결과의 상태 정보를 저장(음수/양수, 0, 오버플로우, 캐리 등)
##### 6. 스택 포인터(SP| Stack Pointer)
- 스택의 꼭대기를 가리키는 레지스터, 스택의 최상단 주소를 저장함.
- 함수 호출이나 인터럽트 처리 시 사용
##### 7. 베이스 레지스터
- '기준 주소'를 저장함.
- 오퍼랜드(변위)를 더하여 실제 메모리 주소를 계산하는데 사용
- 변위 주소 지정 방식 : 오퍼랜드 필드의 값(변위)과 특정 레지서의 값을 더하여 유효 주소 얻기
	- 상대 주소 지정 방식 : 오퍼랜드 + 프로그램 카운터
	- 베이스 레지스터 주소 지정 방식 : 오퍼랜드 + 베이스 레지스터
### 범용 레지스터(General Purpose Register)
다양하고 일반적인 상황에서 자유롭게 사용한다.

## 명령어 세트(Instruction Set)
CPU가 수행할 명령어의 집합
명령어 = 연산 코드(Operation Code) + 오퍼랜드(Operand)
- **연산 코드** : 연산자, '명령어가 수행할 연산' (덧셈, 뺄셈...)
- **오퍼랜드** : 피연산자, '연산에 사용할 데이터가 저장된 위치' (주소, 숫자, 문자...)

## 명령어 사이클(Instruction Cycle)
>하나의 명령어를 처리하는 정형화된 흐름

CPU가 하나의 명령어를 처리하는 과정에는 어떤 정해진 흐름이 있고, 이 흐름을 반복하여 명령어를 처리함. 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 **명령어 사이클**이라고 함.

### 명령어 사이클의 구성
명령어 사이클(Instruction Cycle)은 인출/실행/간접/인터럽트로 나누어짐
- 인출 사이클(Fetch Cycle)
- 실행 사이클(Execute Cycle)
- 간접 사이클(Indirect Cycle)
- 인터럽트(Interrupt)

#### 인출 사이클(Fetch Cycle)
메모리에 저장된 명령어를 실행하기 위해 CPU 내부로 가져오는 단계
<img width="371" height="281" alt="image" src="https://github.com/user-attachments/assets/a86420ee-612e-4425-964c-503f1c136661" />

#### 실행 사이클(Execute Cycle)
CPU로 가져온 명령어를 실행하는 단계
<img width="371" height="302" alt="image" src="https://github.com/user-attachments/assets/c25fce80-22ff-4b06-9d7d-9b801aabe1a8" />

 → 프로그램을 이루는 수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하며 실행됨.

<img width="371" height="311" alt="image" src="https://github.com/user-attachments/assets/5176930c-b326-458c-9449-504570086802" />

#### 간접 사이클(Indirect Cycle)
명령어를 인출해도 바로 실행이 불가능한 경우도 있음. (ex. 간접 주소 지정 방식)
명령어를 실행하기 위해 메모리 접근을 한 번 더 하는 단계

간접 주소 지정 방식을 사용하는 경우, 명령어의 오퍼랜드가 실제 데이터가 아닌 데이터의 주소를 가리킨다. 따라서 메모리에 한 번 더 접근하여 실제 데이터의 주소를 얻어야 한다.
<img width="371" height="275" alt="image" src="https://github.com/user-attachments/assets/b7f6be69-9de6-4e63-bcb4-e404f2305c4c" />

#### 인터럽트(Interrupt)
[[인터럽트|인터럽트]] : CPU의 작업을 방해하는 신호

### 각 단계별 레지스터 동작 과정
![낙서장](https://github.com/user-attachments/assets/3ba5f242-79a5-45e0-9efc-282234cb7cb4)

 1. 프로그램 카운터(PC)에 `1000`이 저장됨 (명령어가 담긴 주소 저장)
 2. 주소 버스로 1000번지를 전달하기 위해 메모리 주소 레지스터(MAR)에 `1000` 저장
 3. '메모리 읽기' 제어 신호와 MAR 값이 제어 버스와 주소 버스를 통해 메모리로 전달
 4. 메모리 1000번지에 저장된 값인 `1101`이 데이터 버스를 통해 메모리 버퍼 레지스터(MBR)로 전달되고, PC가 증가(`+1`)
 5. MBR에 저장된 값이 명령어 레지스터(IR)로 이동
 6. 제어장치는 IR의 명령어를 해석하고 제어 신호 발생

#### 인출 사이클의 과정
1~5번에 해당함.
- PC에 저장된 주소를 MAR에 전달
- MAR의 주소를 바탕으로 메모리의 해당 주소에서 명령어를 인출
- 인출한 명령어를 MBR에 저장
- 다음 명령어 인출을 위해 **PC 값 증가**
- MBR에 저장된 명령어를 IR에 전달

```
T0: PC(1000) → MAR
T1: M[MAR] → MBR (메모리 1000번지의 값 1101 가져옴), PC ← PC+1 
T2: MBR → IR (명령어가 저장됨 ex. ADD addr)
```
#### 실행 사이클의 과정
6번과 명령어를 바탕으로 연산 수행에 해당함.
- 전달받은 명령어를 실행함. (PC 증가할 필요X)

##### Load addr 명령어 수행 예시
메모리 1000번지에 `Load 1500`이라는 명령어가 있다고 가정.
IR로 가져온 명령어에서 `Load 1500` 확인
```
T0: IR(1500) → MAR
T1: M[MAR] → MBR (메모리 1500번지의 데이터를 가져옴)
T2: MBR → 레지스터 (AC 또는 범용 레지스터) 
```

### 명령어 사이클 전체 흐름
```
인출 → 실행 → (간접) → (인터럽트) → 인출 → 실행 → ...
```

CPU는 전원이 꺼질 때까지 이 사이클을 반복한다.
